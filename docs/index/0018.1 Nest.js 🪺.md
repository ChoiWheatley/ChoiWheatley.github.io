---
aliases: 
tags: 
description:
title: 0018.1 Nest.js 🪺
created: 2023-11-10T14:57:24
updated: 2023-11-11T14:49:01
---
- [[0018 Javascript ☕️]]
- [노마드 코더 nest.js](https://nomadcoders.co/nestjs-fundamentals)
	- [노마드 코더 typescript](https://nomadcoders.co/typescript-for-beginners)
- [NestJS로 배우는 백엔드 프로그래밍](https://wikidocs.net/book/7059)
- [공식문서](https://docs.nestjs.com)
___

## README

NestJs 학습을 2023-11-10~2023-11-11 이틀간 진행하기로 했다. 껍데기만 조금 훑는다는 느낌으로 가고 나머지는 직접 구현하면서 채워넣어보자.

## Overview

- NestJS 설치법: 
	- `npm i -g nestjs/cli`
	- `nest new project-name`
	- `nest start`
- 핵심 파일 구조
	- `app.controller.ts`: 컨트롤러는 라우터임
	- `app.controller.spec.ts`: spec이라는 이름은 유닛테스트를 의미함.
	- `app.serivce.ts`: 서비스는 컨트롤러에 의해 호출되는 다양한 콜백들을 담아놓는 파일
	- `app.module.ts`: 프로젝트 메타데이터를 저장하는 곳
	- `main.ts`: 엔트리파일, `app` 생성함
- 빠르게 컴파일하고 실행시키려면... `npm run start -- -b swc`
- hot reloading을 자체적으로 지원한다 : `npm run start:dev`

### Controllers

- request & response를 처리하는 레이어.
- 새 컨트롤러를 만드는 명령어는 `nest g controller <name>`이다. 
- 클래스 어노테이션으로 `@Controller(<path>)`가 달려있다.
- 메서드들이 각각의 엔드포인트로 작용하기 위해선 `@GET([subpath])`와 같은 HTTP 메서드 이름의 어노테이션을 달아야 한다.
- 성공적으로 응답을 반환해야할 때 기본값은 200이고, POST일 경우 201이다. 이를 오버라이드하기 위해선 `@HttpCode(<number>)` 어노테이션을 사용해야 한다. 
	- 에러 status를 반환할 경우 예외를 throw하라던데?
	- 아무 status나 반환하고 싶을땐 express의 코드를 사용하라고..
- **[Request Object](https://docs.nestjs.com/controllers#request-object)**
	- Path 인자는 `@Get(:id)` 어노테이션으로 정의하고 파싱된 인자는 메서드 인자로 들어온다.

	```ts
	@Get(':id')
	fineOne(@Param() params: any): string {
		return param.id + 'cat';
	}
	``` 

	- request 세부사항을 알기 위해선 메서드 파라메터 앞에 `@Req()` 데코레이터를 붙이라고! 

	```ts
	import { Request } from 'express';
	@Get()
	fineOne(@Req() request: Request): string {
		return request.body;
	}
	``` 

	- 이렇게 메서드 파라메터로 넣을 수 있는 데코레이터들로는 `@Res`, `@Next`, `@Session`, `@Param`, `@Body`, `@Query`, `@Headers` 등이 있고 [다음 링크](https://docs.nestjs.com/controllers#request-object)를 참고하시오.
-  deferred response를 리턴해도 된다고. Promise 타입 객체를 리턴하게 되면 [[#RxJS]]의 observable stream으로 리턴이 되고, 스트림이 끝날경우 해당 소스에 알림이 간다고는 하는데 뭔 소린지 잘 모르겠음.
- **[Request Paloads](https://docs.nestjs.com/controllers#request-payloads)**
	- DTO, Data Transfer Object라고 불리우는, 네트워크 전송을 위해 존재하는 객체타입은 클래스로 정의가 되어있다고. DTO 클래스 멤버들은 직렬화 가능한 타입만 들어올 수 있나?
	- [[express.js]]에서 POST요청에 대한 요청의 body를 뜯어 원하는 키값들을 직접 획득했다면, Nest.js는 DTO 객체를 인자로 받아와 곧바로 사용할 수 있다.
	- `@Post() create(@Body() createCatDto: CreateCatDto) {...}
- app.module.ts 파일에 내가 정의한 컨트롤러들을 `@Module()` 데코레이터 안에 넣을 수 있다.

### Providers

의존성 주입될 수 있는 다양한 클래스들이다. 대표적으로 Service, Repository, Factory, Helper 등이 있다. 컨트롤러가 처리할 수 없는 복잡한 작업을 Provider들에게 넘겨주는 예시를 보여주고 있다.

**Inversion of Control**

<https://en.wikipedia.org/wiki/Inversion_of_control>

원래는 유저가 라이브러리 코드를 호출하지만 라이브러리 코드가 인터페이스를 기준으로 유저 코드를 호출할 수 있게 만드는 패턴을 IoC라고 부른다.

Dependency Injection이라고, 생성자 타임에 의존성 Provider를 주입하는 과정을 의미.

## JS async, await, promise

<https://springfall.cc/article/2022-11/easy-promise-async-await>

> OS레벨에서 스케줄링의 대상은 **프로세스**이지만 JS 레벨에서 스케줄링의 대상은 **함수**이다.

따라서, 콜백함수는, 내가 함수를 원할 때 호출하게 만들기 위한 수단으로 나온 것이다.

> JS에서 기다리는 것은 동시에 할 수 있지만, 처리하는 것은 동시에 하지 못한다.

[[tasks, microtasks, queues and schedules {js}]]

## RxJS

- [observable streams](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)
