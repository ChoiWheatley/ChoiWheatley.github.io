---
aliases: 
tags:
  - algorithm
  - recursion
description: 
title: 1074. Z
created: 2023-08-13T13:31:39
updated: 2024-12-27T14:57:36
difficulty: 
status: 
links:
  - http://boj.kr/1074
---
[[0011 Algorithms â™¾ï¸|algorithms]]

## 1ì°¨ ì‹œë„

[[Comparing result with enum in python]]ë¥¼ ì°¸ê³ í•˜ì—¬ r, cê°’ê³¼ ë°°ì—´ì˜ í¬ê¸°ë¥¼ ì„œë¡œ ë¹„êµí•´ ëª‡ì‚¬ë¶„ë©´ì— ìœ„ì¹˜í•´ ìˆëŠ”ì§€ë¥¼ íŒë‹¨í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤.

```python
def sol_recur(n: int, dim: int, r: int, c: int, lo: int, hi: int) -> int:
    if dim == 0:
        return lo
    cell_size = 2 ** (2 * dim - 2)
    match (compare(r, 2 ** (dim - 1)), compare(c, 2 ** (dim - 1))):
        case (Cmp.Less, Cmp.Less):
            # 1ë¶„ë©´ì— ìˆìŒ
            hi = lo + cell_size
        case (Cmp.Less, Cmp.Greater):
            # 2ë¶„ë©´ì— ìˆìŒ
            lo += cell_size
            hi = lo + cell_size
        case (Cmp.Greater, Cmp.Less):
            # 3ë¶„ë©´ì— ìˆìŒ
            lo += cell_size * 2
            hi = lo + cell_size
        case _:
            # 4ë¶„ë©´ì— ìˆìŒ
            lo += cell_size * 3
            hi = lo + cell_size
    return sol_recur(n, dim - 1, r, c, lo, hi)


n, r, c = [int(e) for e in input().split()]

print(sol_recur(n, n, r, c, 0, 2 ** (2 * n)))
```

í•˜ì§€ë§Œ ê²°ê³¼ëŠ” ì¹¼ê°™ì´ ì˜¤ë‹µì´ì—ˆë‹¤. ğŸ˜

ì´ìœ ë¡œ í•˜ì—¬ê¸ˆ `match` ì•ˆì—ì„œ r, cê°’ì„ ì˜ëª» ë¹„êµí•œ ê²Œ ì•„ë‹ê¹Œ ì‹¶ê¸°ëŠ” í•œë°... ê´€ì‹¬ Cellì˜ í¬ê¸°ì™€ ìœ„ì¹˜ê°€ ìê¾¸ ë°”ë€Œë‹ˆê¹Œ r, cë„ ê³„ì† ë°”ê¾¸ì–´ì•¼ í•¨.

â‰¤, <ê°™ì€ equalityë„ ê³ ë ¤í•´ì•¼ê² êµ¬ë‚˜ 

![[Pasted image 20230813150631.png]]

## Greater | Equal

â‰¥ ì‚¬ì¸ì´ ì—†ì—ˆê¸° ë•Œë¬¸ì— ê³„ì† 4ë¶„ë©´ìœ¼ë¡œ ë¹ ì¡Œë˜ ê²ƒì´ì—ˆë‹¤.

```python
def sol_recur(dim: int, r: int, c: int, lo: int, hi: int) -> int:
    if dim == 0:
        return lo
    # ë„“ì´ì™€ ë³€ì˜ ê¸¸ì´ë¥¼ ì €ì¥í•œë‹¤.
    side = 2**dim
    area = side**2
    # ê° ë¶„ë©´ì˜ ë„“ì´ì™€ ë³€ì˜ ê¸¸ì´ë¥¼ ì €ì¥í•œë‹¤.
    cell_side = side // 2
    cell_area = cell_side**2

    match (compare(r, cell_side), compare(c, cell_side)):
        case (Cmp.Less, Cmp.Less):
            # 1ë¶„ë©´ì— ìˆìŒ
            hi = lo + cell_area
        case (Cmp.Less, Cmp.Greater | Cmp.Equal):
            # 2ë¶„ë©´ì— ìˆìŒ
            lo += cell_area
            hi = lo + cell_area
            c -= cell_side
        case (Cmp.Greater | Cmp.Equal, Cmp.Less):
            # 3ë¶„ë©´ì— ìˆìŒ
            lo += cell_area * 2
            hi = lo + cell_area
            r -= cell_side
        case _:
            # 4ë¶„ë©´ì— ìˆìŒ
            lo += cell_area * 3
            hi = lo + cell_area
            r -= cell_side
            c -= cell_side
    return sol_recur(dim - 1, r, c, lo, hi)


if __name__ == "__main__":
    n, r, c = [int(e) for e in input().split()]

    print(sol_recur(n, r, c, 0, 2 ** (2 * n)))
```

## 2024-12-27 ë‹¤ì‹œ ëŒì•„ì™”ë‹¤

### TLDR

ê³„ì‚°ì´ ì˜ ì•ˆ ë§ì„ë• í‘œë¥¼ ì„¸ì›Œê°€ë©° n ê°’ì„ í•˜ë‚˜ì”© ëŠ˜ë ¤ê°€ë©° ë³€ìˆ˜ë“¤ì˜ ê°’ì„ ê³„ì‚°í•´ë³´ëŠ” ìŠµê´€ì„ ê°€ì ¸ë³´ì. í•œ ë²ˆ ë§ë¦¬ë‹ˆê¹Œ ëë„ ì—†ì´ ì‹œê°„ì´ í˜ëŸ¬ê°”ë‹¤.

| n   | size of array | size of part   |
| --- | ------------- | -------------- |
| 1   | 4             | 1              |
| 2   | 16            | 4              |
| 3   | 64            | 16             |
| k   | $2 ^ {2 k}$   | $2^{2(k-1)}$   |

<!-- ë¬¸ì œì— ëŒ€í•œ ê°„ëµí•œ ì„¤ëª… ë° í’€ì´ ì ‘ê·¼ ë°©ì‹ ìš”ì•½ -->

---

### Snippet

```python
def bound_idx(n: int, r: int, c: int) -> int:
    """
    0 1
    2 3
    """
    m = n - 1
    if r < 2**m and c < 2**m:
        return 0
    if r < 2**m and c >= 2**m:
        return 1
    if c < 2**m and r >= 2**m:
        return 2
    return 3


def order_of(n: int, bound_idx: int) -> int:
    """
    ì‚¬ë¶„ë©´ í•˜ë‚˜ì˜ í¬ê¸°ëŠ” 2**2n / 4 ì´ê¸° ë•Œë¬¸ì—
    2 ** (2 * (n - 1)) ì´ë¼ëŠ” ê³µì‹ì´ ë‚˜ì™”ë‹¤.
    """
    return bound_idx * (2 ** (2 * (n - 1)))


def normalize(n: int, r: int, c: int) -> tuple[int, int]:
    """
    normalize current position (r, c) into range([[0, 2**(n-1)], 2**(n-1)])
    """
    m = n - 1
    next_r = r if r < 2**m else r - 2**m
    next_c = c if c < 2**m else c - 2**m

    return (next_r, next_c)


def main(n: int, r: int, c: int) -> int:
    """
    2**n BY 2**n ë°°ì—´ì—ì„œ ì¬ê·€Z ëª¨ì–‘ìœ¼ë¡œ ë°©ë¬¸í•  ë•Œ r,c ë¥¼ ëª‡ë²ˆì§¸ì—
    ë°©ë¬¸í•˜ëŠ”ê°€?
    """
    bound = bound_idx(n, r, c)

    if n == 0:
        return 0

    order = order_of(n, bound)
    next_r, next_c = normalize(n, r, c)

    order += main(n - 1, next_r, next_c)

    return order


if __name__ == "__main__":
    n, r, c = map(int, input().split())
    print(main(n, r, c))

```

<!-- ì£¼ìš” ì½”ë“œ ì‘ì„± -->

---

### Sample Input & Expected Output

#### Input

```
2 3 1
3 7 7
1 0 0
4 7 7
10 511 511
10 512 512
```

#### Expected Output

```
11
63
0
63
262143
786432
```

---

### Notes

- 
