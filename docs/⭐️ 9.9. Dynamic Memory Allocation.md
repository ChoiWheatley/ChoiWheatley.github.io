---
aliases: 
tags: 
description:
title: ⭐️ 9.9. Dynamic Memory Allocation
created: 2023-09-09T13:15:29
updated: 2023-09-09T14:16:26
---
- [[9. Virtual Memory]]
___
32bit word (4 byte)를 기준으로 챕터가 진행된다. double word로 정렬한다는 것은 곧 모든 객체의 주소가 8의 배수가 된다는 것을 의미한다.

동적 메모리 할당자(dynamic memory allocator)로 힙 영역의 메모리를 어떻게 하면 편하게 할당하고 해제할 수 있을지에 대한 고민이 `malloc`의 구현에 영향을 주었다. 동적 메모리 할당 덕분에 우리는 `mmap`과 같은 낮은 수준의 메모리 관리로부터 벗어나게 되었다.

## DUMP

- Explicit Allocator & Implicit Allocator
	- 명시적으로 할당/해제를 하는 C/C++는 Explicit Allocator이고 가비지 컬렉터가 참조 해제된 객체를 소거하는 자바는 Implicit Allocator이다.

### 9.9.1. The `malloc` and `free` functions

- `malloc(size)`
- `free(ptr)`
- `sbrk(incr)`
- `free`로 빈 공간을 다시 채우는 작업에 대한 도식

### 9.9.2. Why Dynamic Memory Allocation?

- 하드코딩된 전역배열을 프로덕션에서 사용하는 것은 미친 짓이기 때문.

### 9.9.3. Allocator Requirenments and Goals

Allocator의 제약조건

- *Handling arbitrary request sequences* 할당과 해제가 꼭 대칭적으로만 이루어질 거라는 보장은 버려라.
- *Making immediate responses to requests* 요청 즉시 메모리 공간을 반환
- *Using only the heap*
- *Aligning blocks (alignment requirement)*
- *Not modifying allocated blocks*

Allocator의 달성수준

- *Maximizing throughput* 임의의 요청에 빠르게 응답할 것
- *Maximizing Memory Utilization* 현재 힙의 크기 대비 할당받은 블럭의 총량의 비율을 높일 것 (구멍의 수를 줄여라)

### 9.9.4. Fragmentation

Throughput에만 신경을 쓴다면 사실 free한 공간을 다시 재활용 하지 않아도 된다. 이 경우 두 가지 파편화가 발생할 수 있다.

1. **Internal Fragmentation** payload(실제로 필요한 용량)보다 할당해준 용량이 더 많은 경우, "고봉밥 할머니 style"
2. **External Fragmentation** 구멍의 총합은 큰데 너무 자잘해서 요청을 받아줄 수 없는 경우 → 휴리스틱 기법을 사용해 external frag를 줄이려고 노력한다. 어떻게? 작은 구멍의 크기보다는 큰 구멍의 크기를 유지하는 방향으로

### 9.9.5. Implementation Issues

결국 throughput과 mem utilization 모두 챙겨야 하는데, 참고할 만한 기준이 있을까?

- *Free block organization* 구멍을 어떻게 추적하지?
- *Placement* 할당요청에 어떤 구멍을 선택하지?
- *Splitting* 할당에 구멍을 메웠다면, 남은 작은 구멍은 어떻게 관리하지?
- *Coalescing* 방금 해제한 메모리 블럭을 어떻게 처리하지?

### 9.9.6. Implicit Free Lists

블럭의 첫번째 워드(head)(4byte)에 블럭에 대한 메타데이터를 저장한다. 별 건 아니고 블럭의 사이즈 (payload + padding)와 할당여부에 대한 정보를 담는다. 

두 필드를 하나의 워드에 담을 수 있는게, 블럭 사이즈는 정렬 때문에 항상 8의 배수이기 때문이다. 따라서 앞의 3자리는 언제나 0인데, 0번째 비트 (LSB)를 0으로 만들면 Free, 1로 만들면 Allocated로 정의한다.

모든 블럭에는 헤더가 있으니까 헤더 정보를 보고 모든 블럭을 순회할 수 있긴 함. `while (*cur & ~7) { cur += sizeof(void *) * (*cur & ~7); }` 루프를 돌면서 계속 다음 블럭의 크기와 할당여부를 찾다가 block size == 0인 순간 힙 영역의 끝에 도달한거임.

헤더 때문에 최소 블럭 사이즈가 2 워드(8bytes) 가 된다.하나는 헤더, 다른 하나는 정렬 조건을 달성하기 위해서.

### 9.9.7. Placing Allocated Blocks

- *First Fit* 걍 처음 길이가 맞는 구멍에 낑겨 들어가기
- *Next Fit* 이전 검색이 중단된 지점에서부터 찾기
- *Best Fit* 모든 구멍을 다 검사한 뒤 들어갈 수 있는 가장 작은 블럭을 찾아 들어간다. => 검색 속도를 빠르게 만든 **Segregated Free List**에 대해 알아볼 것이다!

### 9.9.8. Splitting Free Blocks

### 9.9.9. Getting Additional Heap Memory

### 9.9.10. Coalescing Free Blocks

### 9.9.11. Coalescing with Boundary Tags

### 9.9.12. Putting It Together: Implementing a Simple Allocator

### 9.9.13. Explicit Free Lists

### 9.9.14. Segregated Free Lists
