---
aliases: 
tags: 
description:
title: SQLD
created: 2024-08-23T16:14:41
updated: 2024-08-23T20:29:35
---

## README

내가 모르는 것 위주로 정리할 예정.

## 과목 1 데이터 모델링의 이해

<https://youtu.be/rdfHFnqVoRw?si=27gh-pq_lJcir4IQ>

### 속성

- 주 식별자에 **함수적 종속성** (Functional Dependency)을 가진다 ⇒ 어떤 속성 A의 값에 다른 속성 B도 유일하게 결정된다면 속성 B는 A에 함수적으로 종속됐다고 한다. A → B 라고 표현함.
	- **완전 함수적 종속**: PK를 구성하는 컬럼이 두개 이상일 경우 두 PK를 다 사용해야지 다른 속성이 결정될 경우. EX) 주문번호와 제품번호를 다 알아야지 주문수량을 알 수 있다. EX) 학생번호와 강의명을 다 써야 성적이 식별된다.
	- **부분 함수적 종속**: PK를 구성하는 컬럼 중 일부에 의해 속성이 종속될 때를 말함.
- **기본 속성**은 업무와 가장 직접적으로 연관된 속성 (원금, 예치기간 등)을 의미하고 **설계속성**은 업무를 규칙화 하기 위해 새로 만들어지는 상품코드 같은 속성을 의미하고 **파생속성**은 다른 속성들에 의해 만들어지는 '계산된' 속성을 의미한다.
- **도메인**은 속성 값이 가질 수 있는 값의 범위를 의미한다.

### 관계

- **존재적 관계**는 서로 다른 엔티티의 존재에 영향을 미친다. 예를 들어 부서 엔티티가 삭제되면 사원 엔티티의 존재에 영향을 미친다. **행위적 관계**는 엔티티 간의 행위 (결제, 주문 등)가 있는 것을 의미하고 고객 엔티티의 행동에 의해 주문 엔티티가 발생한다.
- 관계 구성
	- 관계명, 차수(Cardinality), 선택성(Optionality)
- 관계 차수 (Cardinality)
	- **완전 일대일, 선택 일대일**: 두 엔티티가 반드시 존재해야 하는 경우 완전 일대일이고 선택 일대일은 Null이 가능한 경우.
	- 일대다 관계
	- 다대다 관계: Cartesian Product가 발생하기에 JOIN 성능이 좋지 않음 => 연결 엔티티(중계 테이블)의 추가로 성능문제 해소. EX) 구매 이력
- 페어링
	- 관계의 차수는 엔티티 간의 연결방식을 정의한다면 페어링은 두 인스턴스(레코드) 사이의 연결방식을 정의한다. EX) "학생 A가 강의 B를 2023년 1학기에 수강했고 성적은 B+를 받았다"
- 식별자
	- 논리 모델링에서는 식별자가 물리 모델링에서는 KEY가 된다.
	- 논리 모델링에서는 외부 식별자가 물리 모델링에서는 Foreign Key가 된다.
	- 본질 식별자는 비즈니스 프로세스에서 만들어지며, 인조 식별자는 인스턴스를 구분하기 위해 임의로 만들어지는 식별자이다.
	- 식별자의 속성은 엔티티의 비즈니스 성향에 따라서 달라질 수 있다. EX) 우편번호는 배송지 엔티티에서는 주식별자, 내부식별자, 단일식별자, 본질식별자가 될 수 있지만 구매신청 엔티티에서는 주식별자가 아니게 될 수 있다.
- 강한 개체와 약한개체, 식별 관계와 비식별 관계
	- 독립적으로 존재 가능한 엔티티는 강한 개체이다.
	- 식별 관계는 하나의 엔티티의 기본키를 다른 엔티티또한 기본키(중의 하나)로 공유하는 관계를 의미한다.
	- 비식별 관계는 하나의 엔티티의 기본키를 다른 엔티티는 일반 속성으로 관계를 가지는 경우를 의미한다.
- KEY
	- 후보키(Candidate Key)는 **유일성**과 **최소성**을 만족시키는 키이다. not 기본키 and not 후보키 ⇒ 대체키(Alternate Key)
	- **슈퍼키**는 유일성을 만족하지만 **최소성**을 만족시키지 않는 키 EX) 학번 + 이름 

### 정규화

- 목적: 최소한의 데이터를 하나의 엔티티에 넣도록, 중복을 방지하고 데이터 모델의 독립성을 확보하고 데이터 이상현상을 줄이기 위해서.
	- **이상현상**: 인스턴스를 삽입/갱신/삭제 할때 굳이 정의되지 않아도 될 속성까지도 입력하거나 NULL로 만들어야 하는 현상을 의미.
		- 삽입이상
		- 갱신이상
		- 삭제이상
- 정규화를 할수록 엔티티가 분해된다.
- 논리 모델링 수행 시점에서 고려된다.

- 1 정규화 (1NF): 컬럼의 **원자성**을 갖도록 테이블을 분해.
	- 하나의 속성이 하나의 값을 갖도록 만드는 것이기 때문에 (품목 1, 품목 2, 품목 3) 으로 구성된 컬럼을 (품목) 하나의 컬럼으로 합치는 것도 1 정규화라는 것을 알아두자.
- 2 정규화 (2NF): 테이블에 대해 **완전 함수 종속**을 만들도록 테이블을 분해. ([[#속성]] 참고)
- 3 정규화 (3NF): 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분리. EX) 학번이 과목을 결정하고, 전공 교수를 결정한다. 이때 학번이 달라지면 교수도 달라지므로 학번도 교수를 결정한다고 볼 수 있기 때문에 전공과 교수 컬럼을 분리한다.
- BCNF (Boyce-Codd NF): 모든 결정자가 후보키가 되도록 테이블을 분해.
- 4 정규화: 여러 컬럼들이 하나의 컬럼을 종속시키지 않도록 테이블을 분해.
- 5 정규화: JOIN에 의해서 종속성이 발생되는 경우 테이블을 분해.

### 관계와 조인의 이해

- JOIN의 의미
	- 두 테이블의 데이터를 동시에 출력할때 데이터를 연결하는 과정임.
- Self Join (계층형 데이터 모델)
	- 자신과 관계가 발생. 같은 테이블을 여러 번 조인

### NULL

- Null은 집계함수에서 포함이 안된다. 예를 들어 AVG 함수는 NULL을 무시한 행들만의 평균을 리턴하기 때문에 NULL 컬럼의 개수를 포함하고 싶다면 `SUM(COMM) / COUNT(*)` 이렇게 써야한다.
