---
aliases: 
tags: 
description:
title: 3.4 Accessing Information
created: 2023-09-05T12:35:35
updated: 2023-09-06T21:54:39
---
- parent: [[3. Machine Level Representation of Programs]]
___

본 장에선 x86-64 ISA의 어셈블리를 톺아보(~~기엔 너무 깊게 들어가는 것 같지만~~)기로 한다. 시대가 발전해오면서 8086 → IA32 → x86-64로 아키텍처도 함께 발전했는데, 그 유산을 버리지 않고 아직까지도 사용하고 있다. 16개의 레지스터가 있는데, 8086시절에 쓰던 `%ax` ~ `%bp` 까지의 8개의 16비트 레지스터, IA32에서 쓰던 `%eax` ~ `%ebp`까지의 8개의 32비트 레지스터, x86-64에서 쓰는 `%rax` ~ `%rbp` 이렇게 8개의 64비트 레지스터를 사용하고 있다. 같은 이름으로 시작하는 레지스터들은 모두 같은 공간을 가리키고 있지만 그 크기가 다를 뿐이다. 1바이트만 필요하면 `%a` 시리즈를 사용하면 되는 식.

> 서로 다른 레지스터들은 범용목적을 제외하곤 고유한 역할이 있다.

## 3.4.1.  Operand Specifiers

피연산자들의 타입에 대해 알아보자.

- Immediate `$Imm`
	- 값 리터럴을 담는데 쓰임
- Register `R[ra]`
	- 레지스터 이름을 가리킨다.
- Memory `M[Imm]`, `M[Imm + R[rb]]`, `M[R[rb]+R[ri]]`, `M[Imm + R[rb] + R[ri]]`, `M[R[ri] * s]`, `M[Imm + R[ri] * s]`, etc.
	- 메모리 주소값을 참조한다.
	- 메모리 인덱스 연산을 제공하나보네

## 3.4.2. Data Movement Instructions

>  The generality of the operand notation allows a simple data movement instruction to express a range of possibilities that in many machines would require a number of different instructions  
>  피연산자 표기법의 범용성 덕분에 많은 기계에서 여러 명령어가 필요한 다양한 기능을 간단한 데이터 이동 명령어로 표현할 수 있습니다.

크기가 다를뿐, 여러 mov 연산자는 동일한 역할을 가지고 있다. Destination으로 Source 데이터를 옮기는 명령으로 Source, Destination 모두 레지스터, 메모리공간을 뜻할 수는 있지만 Source, Destination 모두 동시에 메모리주소를 가리킬 수는 없다. 따라서 메모리 A에 있는 데이터를 메모리 B로 옮기기 위해선 두 번의 연산이 필요하다.

## 3.4.3. Data Movement Example

단순 값을 수정하는 함수 `exchange`를 GCC로 컴파일 했을때 어떤 어셈블리 코드가 나오는지 직접 실습을 하는 장이다. 
