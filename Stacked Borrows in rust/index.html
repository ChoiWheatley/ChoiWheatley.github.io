
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="site_description">
      
      
        <meta name="author" content="you">
      
      
        <link rel="canonical" href="https://choiwheatley.github.io/Stacked%20Borrows%20in%20rust/">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.18">
    
    
      
        <title>Stacked Borrows in rust - Choi Wheatley's Second Brain</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.26e3688c.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#stacked-borrow" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Choi Wheatley&#39;s Second Brain" class="md-header__button md-logo" aria-label="Choi Wheatley's Second Brain" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Choi Wheatley's Second Brain
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Stacked Borrows in rust
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Choi Wheatley&#39;s Second Brain" class="md-nav__button md-logo" aria-label="Choi Wheatley's Second Brain" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Choi Wheatley's Second Brain
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../test.md" class="md-nav__link">
        About
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<ul>
<li>https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html</li>
<li>unsafe 코드를 작성하고나서부터 상황이 꼬이기 시작했다. 특히 <a href="../MIRI%20-%20Mid-level%20Intermediate%20Representaion%20Interpreter/">MIRI - Mid-level Intermediate Representaion Interpreter</a>를 통한 UB 체크가 실패하고나서부터!</li>
<li>Safe 코드에서 borrow checker는 컴파일 시간에 Stacked Borrow를 체크할 수 있다. 하지만 Unsafe 코드에서는 동작하지 않는다. 따라서 런타임에 멀쩡해 보이는 코드일지라도 MIRI를 사용하여 내가 작성한 코드에 어떤 취약점이 있는지 파악하는 것을 습관화 해야 한다.</li>
<li>그래서, Stacked Borrow가 무엇이냐 하면, 가끔 mutable reference aliasing을 시도할 때 볼 수 있는 컴파일 에러가 바로 그 설명을 한다.</li>
</ul>
<p>다음 코드는 컴파일 에러를 일으킨다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">ref1</span><span class="p">;</span><span class="w"> </span><span class="c1">// mutable reference aliasing happen! (reborrow)</span>

<span class="w">    </span><span class="o">*</span><span class="n">ref1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">ref2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>무엇이 문제인가 보면, <code>ref2</code>가 레퍼런스를 아직 반납하지 않았는데 <code>ref1</code>이 갑자기 자기 것인 냥 사용하고 있다는 것이었다.</p>
<div class="highlight"><pre><span></span><code>error[E0503]: cannot use `*ref1` because it was mutably borrowed
 --&gt; src/main.rs:6:5
  |
4 |     let ref2 = &amp;mut *ref1; // mutable reference aliasing happen!
  |                ---------- borrow of `*ref1` occurs here
5 |
6 |     *ref1 += 1;
  |     ^^^^^^^^^^ use of borrowed `*ref1`
7 |     *ref2 += 2;
  |     ---------- borrow later used here
</code></pre></div>
<p>borrow checker는 여러 reborrowed reference들이 stack의 속성같이 alias 되도록 강제한다. 새로운 alias를 정의한다는 것은 마치 스택에서의 push와 같은 연산을 수행하고, 명시적으로 드랍하지는 않아도 마지막으로 그 alias를 사용한 직후 pop과 같은 연산을 수행한다. 위의 코드를 개념적으로 본다면 다음과 같을 수 있다. 각 블록 안에서는 해당 alias만 사용할 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ref1 borrows data by mutable</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">ref1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ref2 reborrows ref1&#39;s pointee by mutable</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>따라서, 이 컨셉에 따르면 <code>ref2</code> 블록 안에서 <code>ref1</code>을 사용하고 있기 때문에 마치 스택에 최상단 원소를 제거하지도 않은 채 중간 원소를 사용하는 것으로 바라볼 수 있고, 이는 곧 Stacked Borrow 규칙을 위반한 것이 된다.</p>
<blockquote>
<p>Whatever's at the top of the borrow stack is "live" and knows it's effectively unaliased.<br />
빌린 스택의 꼭대기에 있는 것은 무엇이든지 간에 살아있고, 또한 효율적으로 별칭이 없다는 것을 알고 있습니다. (보장합니다)</p>
</blockquote>
<h1 id="stacked-borrow">Stacked Borrow가 뭔지는 이제 알겠어, 근데 왜 필요한 건데?<a class="headerlink" href="#stacked-borrow" title="Permanent link">&para;</a></h1>
<p>프로그래머로 하여금 내가 소유하고 있는 레퍼런스에 대한 참조투명성을 보장하는 아주 훌륭한 지표가 되기 때문이다. C world에서의 포인터는 단순 숫자이다. 따라서 어떤 변수나 객체에 대한 소유권또한 존재하지 않고 단지 내가 어떤 변수에 대한 포인터를 가지고 있는 동안 만큼은 다른 누군가가 같은 주소에 장난질을(값을 변경한다거나, delete를 수행한다거나) 하지 않기를 바랄 뿐이다.</p>
<p>러스트에서 소유권 개념을 적용하면서부터 내가 어떤 변수에 대한 소유권을 가지고 있는 동안 다른 존재가 함부로 그 공간을 훼방 놓을 수 없게 되었다. borrowing도 마찬가지이다. <a href="../Permission%20Handling/">Permission Handling</a>을 공부하면서 느낀 희열의 원천이 바로 이곳인 것이다. </p>
<p>서슬퍼런 눈을 뜬 borrow checker의 감시를 피해 달아난 unsafe realm에서도 MIRI의 칼날을 피해갈 순 없었다. </p>
<h1 id="_1">다음 원칙들만 기억하자.<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<ol>
<li>At the start of a method, use the input references to get our raw pointers</li>
<li>Do our best to only use unsafe pointers from this point on</li>
<li>Convert our raw pointers back to safe pointers at the end if needed</li>
</ol>
<p>다양한 실험 실습은 <a href="https://rust-unofficial.github.io/too-many-lists/fifth-testing-stacked-borrows.html">다음 링크</a> 에서 확인바람.</p>
<h1 id="shared-references-cannot-be-mutated-even-aliased">Shared references cannot be mutated even aliased<a class="headerlink" href="#shared-references-cannot-be-mutated-even-aliased" title="Permanent link">&para;</a></h1>
<p>한 번 불변으로 변수를 빌렸다면 하위 모든 reborrowed references들 또한 불변이어야 한다. (당연한거 아님?) unsafe pointer들은 그딴거 깡끄리 무시하고 아래처럼 <code>as *const i32 as *mut i32</code> 로 다시 가변 원시 포인터로 변환할 수 있는데, 이런 짓 하지 말란거임...</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">opaque_read</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">mref1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mref1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">sref3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">mref1</span><span class="p">;</span><span class="w"> </span><span class="c1">// reborrow as immutable</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sref3</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="c1">// very very unsafe</span>

<span class="w">        </span><span class="o">*</span><span class="n">ptr4</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c1">// Attempting a write access using &lt;2787&gt; at alloc 1461[0x0], but that tag only grants SharedReadOnly permission for this location</span>
<span class="w">        </span><span class="n">opaque_read</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">ptr4</span><span class="p">);</span>
<span class="w">        </span><span class="n">opaque_read</span><span class="p">(</span><span class="n">sref3</span><span class="p">);</span>
<span class="w">        </span><span class="o">*</span><span class="n">ptr2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="o">*</span><span class="n">mref1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="n">opaque_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h1 id="safe-pointers-are-tagged-unsafe-ones-arent">Safe pointers are tagged, unsafe ones aren't<a class="headerlink" href="#safe-pointers-are-tagged-unsafe-ones-arent" title="Permanent link">&para;</a></h1>
<p>아래 코드는 문제를 낳지 않는다. <code>ptr2</code> 부터 <code>ptr5</code>까지 전부 <code>*mut i32</code> 타입인데, 레퍼런스 <code>ref1</code>로부터 내려받은 원시 포인터끼리는 빌림규칙이 적용되지 않는다. 따라서 순서를 뒤섞어 놓는다는 일로 MIRI가 불평을 늘어놓지 않는다는 것이다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">opaque_read</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr2</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr3</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr2</span><span class="p">;</span>

<span class="w">    </span><span class="o">*</span><span class="n">ptr2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">ptr5</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">ptr4</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">ptr3</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">ptr4</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="n">opaque_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h1 id="interior-mutability-with-unsafecell">Interior mutability with <code>UnsafeCell</code><a class="headerlink" href="#interior-mutability-with-unsafecell" title="Permanent link">&para;</a></h1>
<p><code>UnsafeCell</code>은 우리에게 단순 원시 포인터를 넘겨주는 <code>get()</code> 메서드를 가지고 있다. 이는 빌림규칙도 따르지 않고 <code>Cell</code> 처럼 변수나 레퍼런스가 불변이어도 내부는 항상 가변이라는 점.</p>





                
              </article>
            </div>
          
          
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            Back to top
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.instant.prefetch", "navigation.path", "navigation.top"], "search": "../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.220ee61c.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>